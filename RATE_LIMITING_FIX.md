# Supabase Auth Token Refresh Rate Limiting Fix

## Problem
The application was experiencing repeated 429 (Too Many Requests) errors when making POST requests to the Supabase auth token endpoint (`/auth/v1/token?grant_type=refresh_token`). This was causing authentication failures and poor user experience.

## Root Cause
The issue was caused by:
1. **Excessive token refresh requests** - Multiple components making simultaneous auth checks
2. **No rate limiting** - The default Supabase client had no built-in protection against rapid token refresh attempts
3. **No retry logic** - Failed requests weren't handled gracefully with exponential backoff
4. **Multiple auth state instances** - Different components creating separate auth state management

## Solution Implemented

### 1. Enhanced Supabase Client Configuration
**File:** `src/lib/supabase.ts`

- Added **rate limiting for token refresh** with 5-second cooldown
- Implemented **exponential backoff retry logic** for failed requests
- Added **429 error handling** with proper retry-after header support
- Enhanced **error logging** for debugging

### 2. Centralized Auth Hook
**File:** `src/hooks/useAuth.ts`

- Created **rate-limited auth state management** with 2-second cooldown between checks
- Implemented **global auth state prevention** to avoid multiple simultaneous auth checks
- Added **debounced auth state changes** (500ms) to prevent rapid updates
- Provided **singleton pattern** for global auth state sharing

### 3. Updated Debug Component
**File:** `src/app/debug/page.tsx`

- Replaced direct `supabase.auth.getUser()` calls with the new `useAuth` hook
- Separated auth loading from profile loading states
- Improved error handling and user feedback

## Key Features of the Fix

### Rate Limiting
```typescript
// Token refresh rate limiting
let lastTokenRefresh = 0
const TOKEN_REFRESH_COOLDOWN = 5000 // 5 seconds

if (isTokenRefresh) {
  const now = Date.now()
  if (now - lastTokenRefresh < TOKEN_REFRESH_COOLDOWN) {
    console.log('Token refresh rate limited, skipping request')
    throw new Error('Rate limited: Token refresh too frequent')
  }
  lastTokenRefresh = now
}
```

### Exponential Backoff
```typescript
// Implement exponential backoff for failed requests
let retries = 0
const maxRetries = 3

while (retries < maxRetries) {
  try {
    const response = await fetch(url, options)
    
    // If we get a 429 (rate limit), wait before retrying
    if (response.status === 429) {
      const retryAfter = response.headers.get('retry-after')
      const waitTime = retryAfter ? parseInt(retryAfter) * 1000 : Math.pow(2, retries) * 1000
      
      console.log(`Rate limited, waiting ${waitTime}ms before retry ${retries + 1}/${maxRetries}`)
      await new Promise(resolve => setTimeout(resolve, waitTime))
      retries++
      continue
    }
    
    return response
  } catch (error) {
    // Handle errors with exponential backoff
  }
}
```

### Auth State Management
```typescript
// Global state to prevent multiple simultaneous auth checks
let authCheckInProgress = false
let lastAuthCheck = 0
const AUTH_CHECK_COOLDOWN = 2000 // 2 seconds

const checkAuth = useCallback(async () => {
  // Prevent multiple simultaneous auth checks
  const now = Date.now()
  if (authCheckInProgress || (now - lastAuthCheck < AUTH_CHECK_COOLDOWN)) {
    return
  }
  // ... auth check logic
}, [])
```

## Usage

### Using the New Auth Hook
```typescript
import { useAuth } from '@/hooks/useAuth'

function MyComponent() {
  const { user, loading, error, signOut, refreshAuth } = useAuth()
  
  // Use user, loading, error states as needed
  // Call refreshAuth() only when necessary
}
```

### Using Global Auth State
```typescript
import { useGlobalAuth } from '@/hooks/useAuth'

function MyComponent() {
  const { user, loading, error } = useGlobalAuth()
  
  // Shared auth state across components
}
```

## Additional Recommendations

### 1. Monitor Auth Calls
- Add logging to track auth-related API calls
- Monitor for patterns that might cause excessive requests
- Set up alerts for high auth API usage

### 2. Optimize Component Updates
- Use `useMemo` and `useCallback` to prevent unnecessary re-renders
- Avoid calling auth checks in component render cycles
- Batch auth state updates when possible

### 3. Session Management
- Consider implementing session persistence strategies
- Use local storage wisely for auth state caching
- Implement proper session timeout handling

### 4. Error Handling
- Implement user-friendly error messages for auth failures
- Provide fallback authentication flows
- Log errors for monitoring and debugging

## Testing

1. **Load Testing**: Test with multiple concurrent users to ensure rate limiting works
2. **Network Conditions**: Test under poor network conditions to verify retry logic
3. **Auth Flows**: Test all authentication flows (login, logout, refresh)
4. **Error Scenarios**: Test 429 error handling and recovery

## Monitoring

Monitor these metrics:
- Auth API request frequency
- 429 error rates
- Token refresh success/failure rates
- User authentication success rates
- Average auth response times

## Files Modified

1. `src/lib/supabase.ts` - Enhanced client configuration
2. `src/hooks/useAuth.ts` - New auth hook (created)
3. `src/app/debug/page.tsx` - Updated to use new auth hook
4. `RATE_LIMITING_FIX.md` - This documentation (created)

## Backward Compatibility

The changes are backward compatible:
- Existing `createClient()` calls continue to work
- New rate limiting is transparent to existing code
- Components can gradually migrate to use the new auth hook

## Next Steps

1. **Gradual Migration**: Update other components to use the new `useAuth` hook
2. **Performance Monitoring**: Monitor auth-related metrics in production
3. **User Feedback**: Collect feedback on authentication experience
4. **Further Optimization**: Consider additional optimizations based on usage patterns